<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Car Obstacle Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.80.1/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #game-container {
      border-radius: 15px;
      box-shadow: 0 15px 35px rgba(0,0,0,0.3);
      overflow: hidden;
      position: relative;
    }
    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      z-index: 1000;
    }
    .leaderboard {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 15px;
      border-radius: 10px;
      min-width: 200px;
      z-index: 1000;
    }
    .leaderboard h3 {
      margin: 0 0 10px 0;
      text-align: center;
    }
    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      padding: 5px 0;
      border-bottom: 1px solid rgba(255,255,255,0.2);
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div class="ui-overlay">
      <div>ÿßŸÖÿ™€åÿßÿ≤: <span id="score">0</span></div>
      <div>ÿ¨ÿßŸÜ: <span id="lives">3</span></div>
    </div>
    <div class="leaderboard">
      <h3>üèÜ Leaderboard</h3>
      <div id="leaderboard-list"></div>
    </div>
  </div>

  <script>
    // Responsive size
    function getGameSize() {
      const isMobile = /Mobi|Android/i.test(navigator.userAgent);
      if (isMobile) {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const ratio = 9 / 16;
        let gameWidth = w;
        let gameHeight = Math.floor(w / ratio);
        if (gameHeight > h) {
          gameHeight = h;
          gameWidth = Math.floor(h * ratio);
        }
        return { width: gameWidth, height: gameHeight };
      } else {
        return { width: window.innerWidth, height: window.innerHeight };
      }
    }

    let { width, height } = getGameSize();

    // Phaser config
    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      backgroundColor: '#2c3e50',
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
      scene: { preload, create, update },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: width,
        height: height
      }
    };

    // Variables
    let player, obstacles, cursors, score = 0, lives = 3;
    let gameSpeed = 200, obstacleTimer = 0, gameOver = false;
    let gameOverText, restartButton;
    let leaderboard = [];

    // Lane system
    let lanes = []; // filled in create()
    let currentLane = 2; // start in the middle lane
    let moveCooldown = false;

    // Leaderboard
    function loadLeaderboard() {
      const saved = localStorage.getItem('carGameLeaderboard');
      leaderboard = saved ? JSON.parse(saved) : [
        { name: 'ÿπŸÑ€å', score: 2500 },
        { name: 'ŸÅÿßÿ∑ŸÖŸá', score: 2000 },
        { name: 'ŸÖÿ≠ŸÖÿØ', score: 1800 },
        { name: 'ÿ≤Ÿáÿ±ÿß', score: 1500 },
        { name: 'ÿ≠ÿ≥€åŸÜ', score: 1200 }
      ];
      updateLeaderboardDisplay();
    }
    function saveScore(playerScore) {
      const playerName = prompt('ŸÜÿßŸÖ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:') || 'ÿ®ÿßÿ≤€å⁄©ŸÜ';
      leaderboard.push({ name: playerName, score: playerScore });
      leaderboard.sort((a, b) => b.score - a.score);
      leaderboard = leaderboard.slice(0, 10);
      localStorage.setItem('carGameLeaderboard', JSON.stringify(leaderboard));
      updateLeaderboardDisplay();
    }
    function updateLeaderboardDisplay() {
      const list = document.getElementById('leaderboard-list');
      list.innerHTML = '';
      leaderboard.slice(0, 5).forEach((entry, i) => {
        const div = document.createElement('div');
        div.className = 'leaderboard-item';
        div.innerHTML = `<span>${i + 1}. ${entry.name}</span><span>${entry.score}</span>`;
        list.appendChild(div);
      });
    }

    // Phaser Scenes
    function preload() {
      this.add.graphics().fillStyle(0x3498db).fillRect(0, 0, 60, 100).generateTexture('car', 60, 100);
      this.add.graphics().fillStyle(0xe74c3c).fillRect(0, 0, 50, 80).generateTexture('obstacle', 50, 80);
      this.add.graphics().fillStyle(0x34495e).fillRect(0, 0, 800, 600)
        .lineStyle(4, 0xf39c12)
        .lineBetween(200, 0, 200, 600)
        .lineBetween(400, 0, 400, 600)
        .lineBetween(600, 0, 600, 600)
        .generateTexture('road', 800, 600);
    }

    function create() {
      this.add.image(width / 2, height / 2, 'road').setDisplaySize(width, height);

      // Define lanes dynamically (5 lanes evenly spaced)
      lanes = [
        width * 0.2,
        width * 0.35,
        width * 0.5,
        width * 0.65,
        width * 0.8
      ];

      // Player
      player = this.physics.add.sprite(lanes[currentLane], height - 100, 'car');
      player.setCollideWorldBounds(true).setTint(0x2ecc71);

      obstacles = this.physics.add.group();
      cursors = this.input.keyboard.createCursorKeys();
      this.wasd = this.input.keyboard.addKeys('A,D');

      this.physics.add.overlap(player, obstacles, hitObstacle, null, this);

      loadLeaderboard();
      updateUI();
    }

    function update() {
      if (gameOver) return;

      // Handle lane change
      if (!moveCooldown) {
        if (cursors.left.isDown || this.wasd.A.isDown) {
          if (currentLane > 0) {
            currentLane--;
            moveCooldown = true;
            player.x = lanes[currentLane];
            this.time.delayedCall(150, () => moveCooldown = false);
          }
        } else if (cursors.right.isDown || this.wasd.D.isDown) {
          if (currentLane < lanes.length - 1) {
            currentLane++;
            moveCooldown = true;
            player.x = lanes[currentLane];
            this.time.delayedCall(150, () => moveCooldown = false);
          }
        }
      }

      // Spawn obstacles
      obstacleTimer += this.game.loop.delta;
      if (obstacleTimer > 1500) {
        spawnObstacle.call(this);
        obstacleTimer = 0;
      }

      // Move obstacles
      obstacles.children.each(obstacle => {
        obstacle.y += gameSpeed / 60;
        if (obstacle.y > height + 50) {
          obstacle.destroy();
          score += 10;
          updateUI();
        }
      });

      // Increase difficulty
      if (score > 0 && score % 200 === 0) gameSpeed += 0.5;
    }

    function spawnObstacle() {
      const laneIndex = Phaser.Math.Between(0, lanes.length - 1);
      const obstacle = obstacles.create(lanes[laneIndex], -50, 'obstacle');
      obstacle.setVelocityY(gameSpeed);
      obstacle.setTint(Phaser.Utils.Array.GetRandom([0xe74c3c, 0x9b59b6, 0xf39c12, 0xe67e22]));
    }

    function hitObstacle(player, obstacle) {
      obstacle.destroy();
      lives--;
      this.cameras.main.shake(200, 0.02);
      player.setTint(0xff0000);
      this.time.delayedCall(200, () => player.setTint(0x2ecc71));
      updateUI();
      if (lives <= 0) endGame.call(this);
    }

    function endGame() {
      gameOver = true;
      obstacles.setVelocityY(0);
      this.add.graphics().fillStyle(0x000000, 0.8).fillRect(0, 0, width, height);
      gameOverText = this.add.text(width / 2, height / 2 - 50, 'ÿ®ÿßÿ≤€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØ!', {
        fontSize: '48px', fill: '#fff'
      }).setOrigin(0.5);
      this.add.text(width / 2, height / 2, `ÿßŸÖÿ™€åÿßÿ≤ ŸÜŸáÿß€å€å: ${score}`, {
        fontSize: '32px', fill: '#f39c12'
      }).setOrigin(0.5);
      restartButton = this.add.text(width / 2, height / 2 + 80, 'üîÑ ÿ¥ÿ±Ÿàÿπ ŸÖÿ¨ÿØÿØ', {
        fontSize: '24px', fill: '#2ecc71', backgroundColor: '#34495e',
        padding: { x: 20, y: 10 }
      }).setOrigin(0.5).setInteractive();
      restartButton.on('pointerdown', () => { saveScore(score); restartGame.call(this); });
    }

    function restartGame() {
      score = 0; lives = 3; gameSpeed = 200; obstacleTimer = 0; gameOver = false;
      obstacles.clear(true, true);
      if (gameOverText) gameOverText.destroy();
      if (restartButton) restartButton.destroy();
      currentLane = 2;
      player.setPosition(lanes[currentLane], height - 100).setTint(0x2ecc71);
      updateUI();
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
    }

    const game = new Phaser.Game(config);
  </script>
</body>
</html>
