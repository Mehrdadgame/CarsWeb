<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Car Game</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.80.1/phaser.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #game-container {
      border-radius: 8px;
      box-shadow: 0 6px 15px rgba(0,0,0,0.25);
      overflow: hidden;
      position: relative;
    }
    .ui-overlay {
      position: absolute;
      top: 5px;
      left: 5px;
      color: white;
      font-size: 14px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
      z-index: 1000;
    }
    .leaderboard {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 5px;
      border-radius: 4px;
      font-size: 10px;
      min-width: 80px;
      z-index: 1000;
    }
    .leaderboard h3 {
      margin: 0 0 4px 0;
      font-size: 11px;
      text-align: center;
    }
    .leaderboard-item {
      display: flex;
      justify-content: space-between;
      padding: 1px 0;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div class="ui-overlay">
      <div>ÿßŸÖÿ™€åÿßÿ≤: <span id="score">0</span></div>
      <div>ÿ¨ÿßŸÜ: <span id="lives">3</span></div>
    </div>
    <div class="leaderboard">
      <h3>üèÜ</h3>
      <div id="leaderboard-list"></div>
    </div>
  </div>

  <script>
    function getGameSize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const ratio = 9 / 16;
      let gameWidth = w;
      let gameHeight = Math.floor(w / ratio);
      if (gameHeight > h) {
        gameHeight = h;
        gameWidth = Math.floor(h * ratio);
      }
      return { width: gameWidth, height: gameHeight };
    }

    let { width, height } = getGameSize();

    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      backgroundColor: '#2c3e50',
      physics: { default: 'arcade', arcade: { gravity: { y: 0 }, debug: false } },
      scene: { preload, create, update },
      scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: width, height: height }
    };

    let player, obstacles, cursors, score = 0, lives = 3;
    let gameSpeed = 200, obstacleTimer = 0, gameOver = false;
    let gameOverContainer;
    let leaderboard = [];
    let lanes = [], currentLane = 2, moveCooldown = false;

    // leaderboard
    function loadLeaderboard() {
      const saved = localStorage.getItem('carGameLeaderboard');
      leaderboard = saved ? JSON.parse(saved) : [
        { name: 'A', score: 2500 },
        { name: 'B', score: 2000 },
        { name: 'C', score: 1800 },
        { name: 'D', score: 1500 },
        { name: 'E', score: 1200 }
      ];
      updateLeaderboardDisplay();
    }
    function saveScore(playerScore) {
      const playerName = prompt('ŸÜÿßŸÖ ÿÆŸàÿØ ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ:') || 'ÿ®ÿßÿ≤€å⁄©ŸÜ';
      leaderboard.push({ name: playerName, score: playerScore });
      leaderboard.sort((a, b) => b.score - a.score);
      leaderboard = leaderboard.slice(0, 10);
      localStorage.setItem('carGameLeaderboard', JSON.stringify(leaderboard));
      updateLeaderboardDisplay();
    }
    function updateLeaderboardDisplay() {
      const list = document.getElementById('leaderboard-list');
      list.innerHTML = '';
      leaderboard.slice(0, 5).forEach((entry, i) => {
        const div = document.createElement('div');
        div.className = 'leaderboard-item';
        div.innerHTML = `<span>${i + 1}.${entry.name}</span><span>${entry.score}</span>`;
        list.appendChild(div);
      });
    }

    function preload() {
      this.add.graphics().fillStyle(0x3498db).fillRect(0, 0, 60, 100).generateTexture('car', 60, 100);
      this.add.graphics().fillStyle(0xe74c3c).fillRect(0, 0, 50, 80).generateTexture('obstacle', 50, 80);
      this.add.graphics().fillStyle(0x34495e).fillRect(0, 0, 800, 600)
        .lineStyle(4, 0xf39c12).lineBetween(200, 0, 200, 600)
        .lineBetween(400, 0, 400, 600).lineBetween(600, 0, 600, 600)
        .generateTexture('road', 800, 600);
    }

    function create() {
      this.add.image(width / 2, height / 2, 'road').setDisplaySize(width, height);

      lanes = [width * 0.2, width * 0.35, width * 0.5, width * 0.65, width * 0.8];
      player = this.physics.add.sprite(lanes[currentLane], height - 100, 'car').setCollideWorldBounds(true).setTint(0x2ecc71);

      obstacles = this.physics.add.group();
      cursors = this.input.keyboard.createCursorKeys();
      this.wasd = this.input.keyboard.addKeys('A,D');
      this.physics.add.overlap(player, obstacles, hitObstacle, null, this);

      // swipe fix ÿ®ÿ±ÿß€å ŸÖŸàÿ®ÿß€åŸÑ
      let startX = 0;
      this.input.on('pointerdown', pointer => { startX = pointer.x; });
      this.input.on('pointerup', pointer => {
        let diff = pointer.x - startX;
        if (Math.abs(diff) > 40) {
          if (diff < 0) moveLeft.call(this);
          else moveRight.call(this);
        }
      });

      loadLeaderboard();
      updateUI();
    }

    function update() {
      if (gameOver) return;
      if (!moveCooldown) {
        if (cursors.left.isDown || this.wasd.A.isDown) moveLeft.call(this);
        else if (cursors.right.isDown || this.wasd.D.isDown) moveRight.call(this);
      }

      obstacleTimer += this.game.loop.delta;
      if (obstacleTimer > 1500) {
        spawnObstacle.call(this);
        obstacleTimer = 0;
      }
      obstacles.children.each(obstacle => {
        obstacle.y += gameSpeed / 60;
        if (obstacle.y > height + 50) {
          obstacle.destroy();
          score += 10;
          updateUI();
        }
      });
      if (score > 0 && score % 200 === 0) gameSpeed += 0.5;
    }

    function moveLeft() {
      if (currentLane > 0) {
        currentLane--;
        moveCooldown = true;
        player.x = lanes[currentLane];
        this.time.delayedCall(150, () => moveCooldown = false);
      }
    }
    function moveRight() {
      if (currentLane < lanes.length - 1) {
        currentLane++;
        moveCooldown = true;
        player.x = lanes[currentLane];
        this.time.delayedCall(150, () => moveCooldown = false);
      }
    }

    function spawnObstacle() {
      const laneIndex = Phaser.Math.Between(0, lanes.length - 1);
      const obstacle = obstacles.create(lanes[laneIndex], -50, 'obstacle');
      obstacle.setVelocityY(gameSpeed);
      obstacle.setTint(Phaser.Utils.Array.GetRandom([0xe74c3c, 0x9b59b6, 0xf39c12, 0xe67e22]));
    }

    function hitObstacle(player, obstacle) {
      obstacle.destroy();
      lives--;
      this.cameras.main.shake(200, 0.02);
      player.setTint(0xff0000);
      this.time.delayedCall(200, () => player.setTint(0x2ecc71));
      updateUI();
      if (lives <= 0) endGame.call(this);
    }

    function endGame() {
      gameOver = true;
      obstacles.setVelocityY(0);

      gameOverContainer = this.add.container(width / 2, height / 2);
      let bg = this.add.graphics().fillStyle(0x000000, 0.7).fillRoundedRect(-120, -80, 240, 160, 10);
      let title = this.add.text(0, -30, 'ÿ®ÿßÿ≤€å ÿ™ŸÖÿßŸÖ ÿ¥ÿØ!', { fontSize: '20px', fill: '#fff' }).setOrigin(0.5);
      let finalScore = this.add.text(0, 0, `ÿßŸÖÿ™€åÿßÿ≤: ${score}`, { fontSize: '16px', fill: '#f39c12' }).setOrigin(0.5);
      let restart = this.add.text(0, 40, 'üîÑ ÿ¥ÿ±Ÿàÿπ ŸÖÿ¨ÿØÿØ', { fontSize: '14px', fill: '#2ecc71', backgroundColor: '#34495e', padding: { x: 8, y: 4 } })
        .setOrigin(0.5).setInteractive();
      restart.on('pointerdown', () => { saveScore(score); restartGame.call(this); });
      gameOverContainer.add([bg, title, finalScore, restart]);
    }

    function restartGame() {
      score = 0; lives = 3; gameSpeed = 200; obstacleTimer = 0; gameOver = false;
      obstacles.clear(true, true);
      if (gameOverContainer) gameOverContainer.destroy();
      currentLane = 2;
      player.setPosition(lanes[currentLane], height - 100).setTint(0x2ecc71);
      updateUI();
    }

    function updateUI() {
      document.getElementById('score').textContent = score;
      document.getElementById('lives').textContent = lives;
    }

    const game = new Phaser.Game(config);
  </script>
</body>
</html>
